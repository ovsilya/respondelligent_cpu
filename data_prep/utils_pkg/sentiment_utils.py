#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np
from typing import List, Dict, Tuple

"""

original vector formats:

    categories = ["AMBIANCE", "FACILITIES", "FOOD", "SERVICE", "VALUE"]

    hotel_categories = ["FACILITIES", "FOOD", "LOCATION", "ROOM", "SERVICE", "VALUE"]

unified vector format:

    uni_cat = ["FACILITIES", "FOOD", "SERVICE", "VALUE", "AMBIANCE", "LOCATION", "ROOM"]
    
"""

def reshape_restaurant_vector(vec):
    """
    maps restaurant sentiment vector:
        categories = ["AMBIANCE", "FACILITIES", "FOOD", "SERVICE", "VALUE"]
    to:
        uni_cat = ["FACILITIES", "FOOD", "SERVICE", "VALUE", "AMBIANCE", "LOCATION", "ROOM"]
    
    idx mapping:
        1, 2, 3, 4, 0, + zero arrays for hotel-specific categories    
    """
    if len(vec) != 25:
        raise ValueError(f'vector has wrong shape. Expected 25 but got {len(vec)}')
    
    idx_remap = [1, 2, 3, 4, 0, 5, 6]
    vec = vec.reshape(5, 5)
    service_vec = np.zeros(5,)
    room_vec = np.zeros(5,)
    vec = np.vstack([vec, service_vec, room_vec])
    vec = vec[idx_remap]
    return vec
    
def reshape_hotel_vector(vec):
    """
    maps hotel sentiment vector:
        hotel_categories = ["FACILITIES", "FOOD", "LOCATION", "ROOM", "SERVICE", "VALUE"]
    to:
        uni_cat = ["FACILITIES", "FOOD", "SERVICE", "VALUE", "AMBIANCE", "LOCATION", "ROOM"]
    
    idx mapping:
        0, 1, 4, 5, + zero array for restaurant-specific categories, 2, 3
    """
    if len(vec) != 30:
        raise ValueError(f'vector has wrong shape. Expected 30 but got {len(vec)}')
    
    idx_remap = [0, 1, 4, 5, 6, 2, 3]
    vec = vec.reshape(6, 5)
#     print(vec)
    amb_vec = np.zeros(5,)
    vec = np.vstack([vec, amb_vec])
    vec = vec[idx_remap]
    return vec

def reshape_vector(vec, domain):
    """
    wrapper around reshape_*_vector()
    """
    if domain.lower() == 'restaurant':
        return reshape_restaurant_vector(vec).flatten()

    elif domain.lower() == 'hotel':
        return reshape_hotel_vector(vec).flatten()
    
    else:
        raise RuntimeError(f'cannot reshape: ({domain})\n{vec}')


def label_tokens_with_aspect_level_sentiment(d_obj):
    """
    updates d_obj to include token-level sentiment
    annotations
    
    NOTE: this is a slight adaption of a function that originally
    processed (result, doc) tuple in XX_alpha_annotations_with_doc_vec.py
    
    args:
        d_obj: dictionary obj like "token_based_output" as generated by
        `get_all_results()` in
        XX_alpha_annotations_with_doc_vec.py (updated 9
        March 2021)

        e.g.:

            {"text": "wir waren gestern hier. ...",
            "aspect_spans": [{...}, {...}],
            "sentiment_spans": [{...}, {...}],
            "tokens": [{...}, {...}]}
    """
        
    aspect_spans = d_obj["aspect_spans"]
    sentiment_spans = d_obj["sentiment_spans"]
    
    for a, s in zip(aspect_spans, sentiment_spans):
        # ensure that current aspect_span == current sentiment_span
        assert a["start"] == s["start"]
        assert a["end"] == s["end"]

        aspect = a["label"]
        sentim = s["label"]
        token_ids = range(a["token_start"], a["token_end"]+1)
        for i in token_ids:
            # update token with new attribute: sentiment =
            # aspect detected and sentiment polarity
            try:
                d_obj["tokens"][i]["sentiment"] = aspect + '_' + sentim
            except IndexError:
                pass

    return d_obj

    
def fetch_sentiment_and_token_sequence(tokens: List[Dict]) -> Tuple[str]:
    """
    """

    tok_seq = []
    senti_seq = []

    # this ensures we skip erroneous-whitespace tokens!!!
    for tok in tokens:
        if not tok["text"].isspace():
            tok_seq.append(tok["text"]) # = [i["text"] for i in tokens]
            senti_seq.append(tok.get("sentiment", 'O')) # for i in tokens]

    return (' '.join(tok_seq), ' '.join(senti_seq))


if __name__ == "__main__":
    pass